\chapter{The Liquidsoap language}
\section{Liquidsoap execution phases}
There are various stages of running liquidsoap:

\begin{itemize}
\item \textbf{Parsing}: read scripts and scripting expressions, can fail with syntax errors.
\item \textbf{Static analysis}: infer the type of all expressions, leaves some type unknown and may fail with type errors.
\item \textbf{Instantiation}: when script is executed, sources get created. Remaining unknown \href{stream_contents.html}{stream types} are forced according to \verb+frame.*.channels+ settings, \href{clock.html}{clocks} are assigned (but unknown clocks may remain) and some sources are checked to be \href{source.htmls}{infallible}. Each of these steps may raise an error.
\item \textbf{Collection}: Unknown clocks become the default wallclock so that all sources are assigned to one clock. Active sources newly attached to clocks are initialized for streaming, shutdown sources are detached from their clocks, and clocks are started or destroyed as needed. Streaming has started.

\end{itemize}
Usually, liquidsoap is ran by passing one or several scripts and expressions to execute. Those expressions set up some sources, and outputs typically don't change anymore. If those initially provided active sources fail to be initialized (invalid parameter, fail to connect, etc.) liquidsoap will terminate with an error.

It is however possible to \textbf{dynamically} create active sources,
through registered server commands, event handlers, etc.
They will be initialized and run as statically created ones.
In \textbf{interactive} mode (passing the \verb+--interactive+ option)
it is also possible to input expressions in a liquidsoap prompt,
and their execution can trigger the creation of new outputs.

Outputs can be desactivated using \verb+source.shutdown()+:
they will stop streaming and will be destroyed.

The full liquidsoap instance
can be shutdown using the \verb+shutdown()+ command.

\section{Script loading}
When you run liquidsoap for streaming, the command line has the following form:

\begin{verbatim}
$ liquidsoap script_or_expr_1 ... script_or_expr_N
\end{verbatim}
This allows you to ask liquidsoap to load definition and settings from
some scripts so that the become available when processing the next ones.

For example you can store your passwords by defined the variable \verb+xxx+
in \verb+secret.liq+, and then refer to that variable in your main script 
\verb+main.liq+. You would then run \verb+liquidsoap secret.liq main.liq+. If you ever 
need to communicate \verb+main.liq+ there won't be any risk of divulgating your 
password.

\subsection{The pervasive script library}
In fact, liquidsoap also implicitly loads scripts before those that you specify 
on the command-line. These scripts are meant to contain standard utilities.
Liquidsoap finds them in \verb+LIBDIR/liquidsoap/VERSION+ where \verb+LIBDIR+ depends on 
your configuration (it is typically \verb+/usr/local/lib+ or \verb+/usr/lib+) and 
\verb+VERSION+ is the version of liquidsoap (\emph{e.g.} \verb+0.3.8+ or \verb+svn+).

Currently, liquidsoap loads \verb+pervasives.liq+ from the library directory,
and this file includes some others.
You can add your personal standard library in that directory
if you find it useful.



\section{Liquidsoap's scripting language}
Liquidsoap's scripting language is a simple functional language,
with labels and optional parameters.
It is statically typed, but infers types -- you don't have to write any types.
It allows the direct handling of liquidsoap notions such
as \href{sources.html}{sources} and \href{requests.html}{requests},
and also provides a convenient syntax for specifying time intervals.

\subsection{Constants}
The constants and their syntax are quite common:

\begin{itemize}
\item integers, such as \verb+42+;
\item floats, such as \verb+3.14+;
\item booleans \verb+true+ and \verb+false+;
\item strings, such as \verb+"foo"+ or \verb+'bar'+.

\end{itemize}
\textbf{Beware}: \verb+3.0+ is not an integer and \verb+5+ is not a float, the dot matters.

Strings might be surrounded by double or single quotes. In both cases, you can escape the quote you're using: \verb+"He said: \"Hello, you\"."+ is valid but \verb+'He said: "Hello, you".'+ is equivalent and nicer.

Also, you can include variables in a string using the \verb+#{...}+
syntax: 
\verb+"foo #{quote(my_var)} bar"+ is equivalent to
\verb+"foo " ^ quote(my_var) ^ " bar"+.

\subsection{Expressions}
You can form expressions by using:

\begin{itemize}
\item Constants and variable identifiers. Identifiers start with an alphabetic character or an underscore, followed by alphanumerics, underscores, dots and quotes: \verb+[A-Z a-z _][A-Z a-z 0-9 _.']*+.
\item Lists and pairs: \verb+[expr,expr,...]+ and \verb+(expr,expr)+.
\item Comparison of values is done using \verb+expr == expr+ and its negation is \verb+expr != expr+. Most other usual operations are available, allowing usual things like \verb+1+1 < 11+.
\item Application \verb+f(x,y)+ of arguments to a function. Application of labeled parameters is as follows: \verb+f(x,foo=1,y,bar="baz")+. The interest of labels is that the order of two parameters doesn't matter as long as they have different labels.
\item Anonymous functions: \verb+fun (arglist) -> expr+. Some arguments might have a label or an optional value. For example, the definition of a function with two named parameters, the second one being optional with default value \verb+13+ is as follows: \verb+fun (~foo,~bar=13) -> ...+.
\item Definitions using def-end: \verb+def pi = 3.14 end+ defining a ground value, \verb+def source(x) = wrap2(wrap1(x)) end+ defining a function. The \verb+=+ is optional, you may prefer multi-line definitions without it. The arguments of a defined function are specified in the same way as for anonymous functions.
\item Shorter definitions using the equality: \verb+pi = 3.14+. This is never an assignment, only a new local definition!
\item Conditionals \verb+if expr then expr else expr end+, or more generally \begin{verbatim}
if expr then expr (elsif expr then expr)* (else expr)? end
\end{verbatim}
. The \verb+else+ block can be omitted if the purpose of the conditional is not to compute a value (\emph{e.g.} an integer or a list of strings) but only to have a side effect (\emph{e.g.} printing something in one case, not doing anything in the other).
\item Sequencing: expressions may be sequenced, just juxtapose them. Usually one puts one expression per line. Optionally, they can be separated by a semicolon. The evaluation of a sequence triggers that of all of its sub-expressions, its value is that of the last sub-expression. Accordingly, the type of a sequence is that of its last sub-expression.
\item Parenthesis can be used to delimit explicitly expressions. In some places where only expressions can be written, as opposed to sequences of expressions, the \verb+begin .. end+ block can be used to explicitly form a simple expression from a sequence. This notably happens with the simple form of definitions without \verb+def .. end+, and in the body of anonymous functions. For example \verb+fun (x) -> f1(x) ; f2(x)+ will be read as \verb+(fun (x) -> f1(x)) ; f2(x)+ not as \verb+fun (x) -> begin f1(x) ; f2(x) end+.
\item Code blocks: \verb+{ expr }+ is a shortcut for \verb+fun () -> expr+.

\end{itemize}
\textbf{No assignation, only definitions.} \verb+x = expr+ doesn't modify \verb+x+, it just defines a new \verb+x+. The expression \begin{verbatim}
(x = s1 ; def y = x = s2 ; (x,s3) end ; (y,x))
\end{verbatim}
 evaluates to \verb+((s2,s3),s1)+.

\textbf{Function.} The return value of a function is the evaluation of its body where parameters have been substituted by their values. Accordingly, the type of the body is the return type of the function. If the body is a sequence, the return value will thus be its last expression, and the return type its type.

\begin{verbatim}
def foo ()
  a = bar()
  b = 1
  "string"
end
# The return type of foo is string.
# The full type of foo is ()->string.
\end{verbatim}
\textbf{Type of an application.} The type of an application is the return type of function if all mandatory arguments are applied. With the function \verb+foo+ previously defined, \verb+foo()+ is a string. Otherwise, the application is ``partial'', and the expression still has a function type.

\textbf{Partial application.} Application of arguments can be partial. For example if \verb+f+ takes two integer arguments, \verb+f(3)+ is the function waiting for the second argument. This can be useful to instantiate once for all dummy parameters of a function:

\begin{verbatim}
out = output.icecast(%vorbis, host="streamer",port="8080",
                            password="sesame")
# out is a function waiting for the other parameters
out(bitrate=112, my_radio)
\end{verbatim}
\textbf{Labels.} Labeled and unlabeled parameters can be given at any place in an application. The order of the arguments is up to permutation of arguments of distinct labels. For example \verb+f(x,foo=1)+ is the same as \verb+f(foo=1,x)+, both are valid for any function \verb+f(x,~foo,...)+. It makes things easier for the user, and gives its full power to the partial application.

\textbf{Optional arguments.} Functions can be defined with an optional value for some parameter (as in \verb+def f(x="bla",~foo=1) = ... end+), in which case it is not required to apply any argument on the label \verb+foo+. The evaluation of the function is triggered after the first application which instantiated all mandatory parameters.

\subsection{Types}
We believe in static typing especially for a script which is intended to run during weeks: we don't want to notice a mistake only when the special code for your rare live events is triggered! Moreover, we find it important to show that even for a simple script language like that, it is worth implementing type inference. It's not that hard, and makes life easier.

The basic types are \verb+int+, \verb+float+, \verb+bool+ 
and \verb+string+.
Corresponding to pairs and lists,
you get \verb+(T*T)+ and \verb+[T]+ types --
all elements of a list should have the same type.
For example, \verb+[(1,"un"),(2,"deux")]+
has type \verb+[(int*string)]+.

There are several types that are specific to liquidsoap, such as
\verb+source+, \verb+request+, \verb+format+.
Those three types are parametrized by the kind of stream that they
carry. This is described in more details in a
\href{stream_content.html}{dedicated page}.

A function type is noted as \verb+(arg_types) -> return_type+. Labeled arguments are denoted as \verb+~label:T+ or \verb+?label:T+ for optional arguments. For example the following function has type
\begin{verbatim}
(source,source,?jingle:string) -> source
\end{verbatim}
.

\begin{verbatim}
fun (from,to,~jingle=default) ->
  add ([ sequence([single(jingle), fallback([])]),
         fade.initial(to) ])
\end{verbatim}
\subsection{Time intervals}
The scripting language also has a syntax extension for simply specifying time intervals.

A date can be specified as \verb+_w_h_m_s+ where \verb+_+ are integers. It has the following meaning:

\begin{itemize}
\item \verb+w+ stands for weekday, ranging from 0 to 7, where 1 is monday, and sunday is both 0 and 7.
\item \verb+h+ stands for hours, ranging from 0 to 23.
\item \verb+m+ stands for minutes, from 0 to 59.
\item \verb+s+ stands for seconds, from 0 to 59.

\end{itemize}
All components \verb+w+, \verb+h+, \verb+m+ and \verb+s+ are optional. Finally, the \verb+m+ can be omitted in dates of the form \verb+_h_+ such as \verb+12h30+.

It is possible to use 24 (resp. 60) as the upper bound for hours (resp. seconds or minutes) in an interval, for example in \verb+12h-24h+.

Time intervals can be either of the form \verb+DATE-DATE+ or simply \verb+DATE+. Their meaning should be intuitive: \verb+10h-10h30+ is valid everyday between 10:00 and 10:30; \verb+0m+ is valid during the first minute of every hour.

This is typically used for specifying switch predicates:

\begin{verbatim}
switch([
  ({ 20h-22h30 }, prime_time),
  ({ 1w }, monday_source),
  ({ (6w or 7w) and 0h-12h }, week_ends_mornings),
  ({ true }, default_source)
])
\end{verbatim}
\subsection{Includes}
You can include other files,
to compose complex configurations from
multiple blocks of utility or configuration directives.

\begin{verbatim}
# Store passwords in another configuration file,
# so that the main config can be safely version-controlled.
%include "passwords.liq"

# Use the definitions from the other file here.
\end{verbatim}
In the command \verb+%include "file"+ the path is relative to
the script file. In \verb+%include &lt;file&gt;+, it is relative
to the library directory of liquidsoap.


\section{Sources}
Using liquidsoap is about writing a script describing how to build what you want. It is about building a stream using elementary streams and stream combinators, etc. Actually, it's a bit more than streams, we call them sources -- in liquidsoap's code there is a \verb+Source.source+ type, and in \verb+*.liq+ scripts one of the elementary datatypes is source.

A source is a stream with metadata and track annotations. It is discretized as a stream of fixed-length buffers of raw audio, the frames. Every frame may have metadata inserted at any point, independently of track boundaries. At every instant, a source can be asked to fill a frame of data. Track boundaries are denoted by a single denial of completely filling a frame. More than one denial is taken as a failure, and liquidsoap chooses to crash in that case.

To build sources in liquidsoap scripts, you need to call functions which return type is \verb+source+. For convenience, we categorize these functions into three classes. The \emph{sources} (sorry for redundancy, poor historical reasons) are functions which don't need a source argument -- we might call them elementary sources. The \emph{operators} need at least one source argument -- they're more about stream combination or manipulation. Finally, some of these are called \emph{outputs}, because they are active operators (or active sources in a few cases): at every instant they will fill their buffer and do something with it. Other sources just wait to be asked (indirectly or not) by an output to fill some frame.

All sources, operators and outputs are listed in the \href{reference.html}{scripting API reference}.

\subsection{How does it work?}
To clarify the picture let's study in more details an example:

\begin{verbatim}
radio =
  output.icecast(
    %vorbis,mount="test.ogg",
    random(
      [ jingle ,
        fallback([ playlist1,playlist2,playlist3 ]) ]))
\end{verbatim}
At every cycle, the output asks the \verb+random+ node for data,
until it gets a full frame of raw audio.
Then, it encodes the frame and sends it to the Icecast server.
Suppose \verb+random+ has chosen the \verb+fallback+ node,
and that only \verb+playlist2+ is available, and thus played.
At every cycle, the buffer is passed from \verb+random+ to
\verb+fallback+ and then to ``playlist2</code> which fills it,
returns it to \verb+fallback+ which returns it to \verb+random+
which returns it to the output. Every step is local.

At some point, \verb+playlist2+ ends a track.
The fallback detects that on the returned buffer,
and selects a new child for the next filling,
depending on who's available.
But it doesn't change the buffer, and returns it to \verb+random+,
which also (randomly) selects a new child at this point,
before returning the buffer to the output.
On next filling, the route of the frame can be different.

It is possible to have the route changed inside a track,
for example using the \verb+track_sensitive+ option of fallback,
which is typically done for instant switches to live shows when they start.

\subsection{Fallibility}
By default, liquidsoap outputs are meant to emit a stream without
discontinuing. Since this stream is provided by the source passed to the
output operator, it is the source responsibility to never fail.
Liquidsoap has a mechanism to verify this, which helps you think of
all possible failures, and prevent them.
Elementary sources are either \emph{fallible} or \emph{infallible}, and this
\emph{liveness type} is propagated through operators to finally
compute the type of any source.
For example,
a \verb+fallback+ or \verb+random+ source is infallible
if an only if at least one of its children is infallible,
and a \verb+switch+ is infallible if and only if it has one infallible
child guarded by the trivial predice \verb+{ true }+.

On startup, each output checks the liveness type of its input source,
and issues an error if it is fallible. The typical fix for such problems
is to add one fallback to play a default file or a checked playlist
(\verb+playlist.safe+) if the normal source fails.
One can also use the \verb+mksafe+ operator that will insert silence
during failures.

If you do not care about failures, you can pass the parameter 
\verb+fallible=true+ to most outputs. In that case, the output
will accept a fallible source, and stop whenever the source fails,
to restart when it is ready to emit a stream again.

\subsection{Caching mode}
In some situations, a source must take care of the consistency of its 
output. If it is asked twice to fill buffers during the same cycle, it 
should fill them with the same data. Suppose for example that a playlist is 
used by two outputs, and that it gives the first frame to the first 
output, the second frame to the second output: it would give the third frame 
to the first output during the second cycle,
and the output will have missed one frame.

It is sometimes useful to keep this is mind to understand the behaviour
of some complex scripts. The high-level picture is enough for users,
more details follow for developers and curious readers.

The sources detect if they need to remember (cache) their previous output in 
order to replay it. To do that, clients of the source must register in 
advance. If two clients have registered, then caching should be enabled. 
Actually that's a bit more complicated, because of transitions. Obviously the 
sources which use a transition involving some other source must register to 
it, because they may eventually use it. But a jingle used in two transitions 
by the same switching operator doesn't need caching. The solution involves two 
kinds of registering: \emph{dynamic} and \emph{static activations}. Activations are 
associated with a path in the graph of sources' nesting. The dynamic 
activation is a pre-registration allowing a single real \emph{static activation}
to come later, possibly in the middle of a cycle.
Two static activations trigger caching. The other reason for enabling caching
is when there is one static activation and one dynamic activation which 
doesn't come from a prefix of the static activation's path. It means that the 
dynamic activation can yield at any moment to a static activation and that the 
source will be used by two sources at the same time.

\subsection{Execution model}
In your script you define a bunch of sources interacting together. Each
source belongs to a \href{clocks.html}{clock}, but clocks only have direct access
to \emph{active sources}, which are mostly outputs.
At every cycle of the clock, active sources are animated: a chunk of stream
(frame) is computed, and potentially outputted one way or another.

This streaming task is the most important and shouldn't be disturbed.
Thus, other tasks are done in auxiliary threads:
file download, audio validity checking, http polling, playlist reloading...
No blocking or expensive call should be done in streaming threads.
Remote files are completely downloaded to a local temporary file
before use by the root thread. It also means that you shouldn't access NFS
or any kind of falsely local files.


\section{Stream contents}
In liquidsoap, a stream may contain any number of audio, video and
MIDI channels. As part of the type checking of your script,
liquidsoap checks that you make a consistent use of stream contents,
and also guesses what kind of stream your script is intended to
work on. As with other infered parameters, you do not necessarily
need to read about stream contents typing if you're still learning
the ropes of liquidsoap, but you might eventually need to know a
little about it.

The content of a stream is described by the audio, video and MIDI
arities. An arity might be fixed or variable. Fixed arities are usual
natural numbers, described a number of channels that does change over
time. For example, the stream type \verb+(2,0,0)+ describes
streams that always have 2 audio channels and no channel of another
type. Variable arities describes numbers of channels that vary over
time. For example, the stream type \verb+(*,0,0)+ describes
a stream which contains only audio, but whose number of channels
might change at anytime -- think of playing files, some of which
being stereo, some mono, and some videos without any audio content.
The stream type \verb+(*+1,0,0)+ also describes a variable
number of audio channels, but with the guarantee that there will
always be at least one.

In liquidsoap script language, there are three sorts of objects
that rely on stream types: sources, requests and encoding formats.
A \href{sources.html}{source} produces a stream,
and it is important what kind of stream
it produces when composing it with other sources.
A \href{requests.html}{request} is an abstract notion of file,
often meant to be decoded, and it is useful to know into what
kind of stream it is meant to be decoded.
Finally, a \href{encoding_formats.html}{format} describes how a stream
should be encoded (\emph{e.g.}, before output in a file or via icecast),
and the stream content is also useful here for the format
to make sense.

In this page, we explain how liquidsoap uses stream types
to guess and check what you're doing.

\subsection{Global parameters}
You might have noticed that our description of stream contents is
missing some information, such as sample rate, video size, etc.
Indeed, that information is not part of the stream types, which is
local to each source/request/format, but global in liquidsoap.
You can change it using the \verb+frame.audio/video.*+
settings, shown here with their default values:

\begin{verbatim}
set("frame.audio.samplerate",44100)
set("frame.video.width",320)
set("frame.video.height",240)
set("frame.video.samplerate",25)
\end{verbatim}
\subsection{Checking stream contents}
Checking the consistency of use of stream contents is done as part
of type checking. There is not so much to say here, except that you
have to read type errors. We present a few examples.

For example, if you try to send an ALSA input to a SDL input using
\verb+output.sdl(input.alsa())+, you'll get the following:

\begin{verbatim}

At line 1, char 22-23:
  this value has type
    source(audio=?A+1,video=0,midi=0)
    where ?A is a fixed arity type
  but it should be a subtype of
    source(audio=0,video=1,midi=0)
\end{verbatim}
It means that a source with exactly onevideo channel was expected
by the SDL output, but the ALSA output can only offer sources
producing audio.
By the way,
\verb+?A+1 where ?A is fixed+ means that the ALSA input will
accept to produce any number of channels, fixed once for
all: it will attempt to initialize the soundcard with that number of
channels and report a runtime error if that fails.

\subsection{Conversions}
The above example did not make much sense, but in some cases you'll
get a type error on seemingly meaningul code, and you'll wonder how
to fix it. Often, it suffices to perform a few explicit conversions.

Consider another example involving the SDL output, where we also try
to use AO to output the audio content of a video:
<code>output.ao(output.sdl(single(``file.ogv'')))/<code>.
This won't work, because the SDL output expects a pure video stream,
but AO wants some audio. The solution is to split the stream in
two, dropping the irrelevant content:

\begin{verbatim}
s = single("file.ogv")
output.sdl(drop_audio(s))
output.ao(drop_video(s))
\end{verbatim}
Currently, the video dropping is useless because AO tolerates
(and ignores) non-audio channels.

If you want to support both mono and stereo (and more) files within
the same playlist, you'll need your \verb+playlist+
or \verb+single+ instance to have type
\verb+source(*+1,0,0)+.
But this content type won't be supported by most operators, which
require fixed arities. What you need to do is use \verb+audio_to_stereo+
which will normalize your variable arity audio into a fixed stereo audio.

The last conversion is muxing.
It is useful to add audio/video channels to a pure video/audio stream.
See \verb+mux_video+, \verb+mux_audio+ and \verb+mux_midi+.

\subsection{Type annotations}
You now have all the tools to write a correct script.
But you might still be surprised by what stream content liquidsoap
guesses you want to use.
This is very important, because even if liquidsoap finds a type
for which it accepts to run, it might not run as you intend:
a different type might mean a different behavior
(not the intended number of audio channels, no video, etc).

Before reading on how liquidsoap performs this inference,
you can already work your way to the intended type by using type
annotations.

For example, with \verb+output.alsa(input.alsa())+,
you'll see that liquidsoap decides that stereo audio should be used,
and consequently the ALSA I/O will be initialized with two channels.
If you want to use a different number of channels,
for example mono, you can explicitly specify it using:

\begin{verbatim}
(output.alsa(input.alsa()):source(1,0,0))
\end{verbatim}
\subsection{Guessing stream contents}
When all other methods fail, you might need to understand a little more
how liquidsoap guesses what stream contents should be used for
each source.

First, liquidsoap guesses as much as possible
(without making unnecessary assumption) from what's been given in the
script.
Usually, the outputs pretty much determine what sources should contain.
A critical ingredient here is often the
\href{encoding_formats.html}{encoding format}. For example, in

\begin{verbatim}
output.icecast(%vorbis,mount="some.ogg",s)
\end{verbatim}
\verb+%vorbis+ has type \verb+format(2,0,0)+, hence \verb+s+
should have type \verb+source(2,0,0)+. This works in more complex
examples, when the types are guessed successively for several intermediate
operators.

After this first phase, it is possible that some contents are still
undetermined. For example in \verb+output.alsa(input.alsa())+,
any number of audio channels could work, and nothing helps us determine
what is intended. At this point, the default numbers of channels are
used. They are given by the setting 
\verb+frame.audio/video/midi.channels+ (whose defaults are respectively
\verb+2+, \verb+0+ and \verb+0+). In our example,
stereo audio would be chosen.








\section{List of formats and their syntax}
Since after version 0.9.3, liquidsoap has decoding formats. These are
special values describing how to encode raw data.
Practically, this means that instead of writing:

\begin{verbatim}
output.icecast.vorbis(quality=0.3,samplerate=44100,...)
\end{verbatim}
you shall now write:

\begin{verbatim}
output.icecast(%vorbis(quality=0.3,samplerate=44100),etc)
\end{verbatim}
The same goes for \verb+output.file+ and for other formats.


All parameters are optional, and the parenthesis are not needed
when no parameter is passed. In the following default values
are shown.
As a special case, the keywords \verb+mono+ and \verb+stereo+ can be used to indicate
the number of channels (whether is is passed as an integer or a boolean).

\subsection{MP3}
\begin{verbatim}
%mp3(stereo=true, samplerate=44100, bitrate=128, quality=5, id3v2=false)
\end{verbatim}
\begin{itemize}
\item Only one of \verb+bitrate+ or \verb+quality+ should be specified.
\item \verb+id3v2=true+ is only valid if liquidsoap has been compiled with taglib support.

\end{itemize}
\subsection{WAV}
\begin{verbatim}
%wav(stereo=true, channels=2, samplesize=16, header=true, duration=10.)
\end{verbatim}
If \verb+header+ is \verb+false+, the encoder outputs raw PCM. \verb+duration+ is optional
and is used to set the WAV length header.

Because Liquidsoap encodes a possibly infinite stream, there
is no way to know in advance the duration of encoded data. Since WAV header
has to be written first, by default its length is set to the maximun possible 
value. If you know the expected duration of the encoded data and you actually 
care about the WAV length header then you should use this parameter.

\subsection{Ogg}
The following formats can be put together in an Ogg container.
The syntax for doing so is \verb+%ogg(x,y,z)+ but it is also
possible to just write \verb+%vorbis(...)+, for example, instead
of \verb+%ogg(%vorbis(...))+.

\subsubsection{Vorbis}
\begin{verbatim}
# Variable bitrate
%vorbis(samplerate=44100, channels=2, quality=0.3)
% Average bitrate
%vorbis.abr(samplerate=44100, channels=2, bitrate=128, max_bitrate=192, min_bitrate=64)
# Constant bitrate
%vorbis.cbr(samplerate=44100, channels=2, bitrate=128)
\end{verbatim}
Quality ranges from -0.2 to 1,
but quality -0.2 is only available with the aotuv implementation of libvorbis.

\subsubsection{Theora}
\begin{verbatim}
%theora(quality=40,width=w,height=h,
        picture_width=w,picture_height=h,
        picture_x=0, picture_y=0,
        aspect_numerator=1, aspect_denominator=1,
        keyframe_frequency=64, vp3_compatible=false,
        soft_target=false, buffer_delay=0.1,
        speed=0)
\end{verbatim}
You can also pass \verb+bitrate=x+ explicitly instead of a quality.
The default dimensions are liquidsoap's default,
from the settings \verb+frame.video.height/width+.

\subsubsection{Dirac}
\begin{verbatim}
%dirac(quality=35,width=w,height=h,
       picture_x=0, picture_y=0,
       aspect_numerator=1, aspect_denominator=1)
\end{verbatim}
\subsubsection{Speex}
\begin{verbatim}
%speex(stereo=false, samplerate=44100, quality=7,
       mode=[wideband|narrowband|ultra-wideband],
       frames_per_packet=1,
       complexity=none)
\end{verbatim}
You can also control quality using \verb+abr=x+ or \verb+vbr=y+.

\subsubsection{Flac}
The flac encoding format comes in two flavors:

\begin{itemize}
\item \verb+%flac+ is the native flac format, useful for file output but not for streaming purpose
\item \verb+%ogg(%flac,...)+ is the ogg/flac format, which can be used to broadcast data with icecast

\end{itemize}
The parameters are:

\begin{verbatim}
%flac(samplerate=44100, 
      channels=2, 
      compression=5, 
      bits_per_sample=16)
\end{verbatim}
\verb+compression+ ranges from 0 to 8 and \verb+bits_per_sample+ should be one of: \verb+8+, \verb+16+ or \verb+32+.

\subsection{AAC}
The syntax for the internal AAC encoder is:

\begin{verbatim}
%aac(channels=2, samplerate=44100, bitrate=64, adts=true)
\end{verbatim}
\subsection{AAC+}
The syntax for the internal AAC+ encoder is:

\begin{verbatim}
%aacplus(channels=2, samplerate=44100, bitrate=64)
\end{verbatim}
\subsection{External encoders}
For a detailed presentation of external encoders, see \href{external_encoders.html}{this page}.

\begin{verbatim}
%external(channels=2,samplerate=44100,header=true,
          restart_on_crash=false,
          restart_on_new_track,
          restart_after_delay=<int>,
          process="")
\end{verbatim}
Only one of \verb+restart_on_new_track+ and \verb+restart_after_delay+ should
be passed. The delay is specified in seconds.
The encoding process is mandatory, and can also be passed directly
as a string, without \verb+process=+.

\section{Formats determine the stream content}
In most liquidsoap scripts, the encoding format determines what
kind of data is streamed.

The type of an encoding format depends on its parameter.
For example, \verb+%mp3+ has type \verb+format(audio=2,video=0,midi=0)+
but \verb+%mp3(mono)+ has type \verb+format(audio=1,video=0,midi=0)+.

The type of an output like \verb+output.icecast+
or \verb+output.file+ is something like
\begin{verbatim}
(...,format('a),...,source('a))->source('a)
\end{verbatim}
.
This means that your source will have to have the same type as your format.

For example if you write
\begin{verbatim}
output.file(%mp3,"/tmp/foo.mp3",playlist("~/audio"))
\end{verbatim}

then the playlist source will have to stream stereo audio.
Thus it will reject mono and video files.

\section{Technical details}
You can store an atomic format in a variable, it is a value like another:
\verb+fmt = %mp3+. However, an atomic format is an atomic constant despite its
appearance. You cannot use a variable for one of its parameters: for
example 

\begin{verbatim}
x = 44100
%vorbis(samplerate=x)
\end{verbatim}
is not allowed,
you must write \verb+%vorbis(samplerate=44100)+.

In programming languages like ML, the typing of \verb+printf+ is a bit special.
Alone, \verb+printf+ has an esoteric type. Together with its parameter, it
takes a meaningful type, for example \verb+printf "An integer: %d\n"+ has type
\verb+int -> unit+. So, the format string \verb+"An integer: %d\n"+ is not a string
at all, it has a more complex type, and cannot be manipulated as a string.
Our encoding formats have a similar role, hence the symbol \verb+%+.





\section{Customize metadata}
Liquidsoap has several mechanism for manipulating the metadata attached to your stream. In this page we quickly detail and compare the different operators, see the \href{reference.html}{language reference} for full details about them.

\textbf{Warning}. The protocol used by Shoutcast and Icecast before version 2 does not support many fields. It mainly support one: \verb+song+. So, if you need to customize the metadata displayed by these servers, you should customize only the \verb+song+ metadata.

\subsection{Rewrite metadata}
\verb+rewrite_metadata+ rewrites metadata using a list of (target,rules). The semantic for the replacement rules is that of the \verb+%+ function. Namely, \verb+(pattern % [...,(k,v),...])+ changes in \verb+pattern+ occurences of:

\begin{itemize}
\item \verb+'$(k)'+ into \verb+"v"+;
\item \verb+'$(if $(k2),"a","b")'+ into \verb+"a"+ if \verb+k2+ is found in the list, \verb+"b"+ otherwise.

\end{itemize}
A sample code using this operator can be:

\begin{verbatim}
# The 'display_artist' field is passed using annotate.
pattern = 
  '$(if $(display_artist),"$(display_artist)","$(artist)")'
rewrite_metadata([("artist",pattern)],source)
\end{verbatim}
\subsection{Map\_metadata }
The \verb+map_metadata+ operator applies a specified function to transform each metadata chunk of a stream. It can be used to add or decorate metadata, but is also useful in more complex cases.

A simple example using it is:

\begin{verbatim}
# A function applied to each metadata chunk
def append_title(m) =
  # Grab the current title
  title = m["title"]

  # Return a new title metadata
  [("title","#{title} - www.station.com")]
end

# Apply map_metadata to s using append_title
s = map_metadata(append_title, s)
\end{verbatim}
The effect of \verb+map_metadata+ by default is to update the metadata with the returned values. 
Hence in the function \verb+append_title+ defined in the code above returns a new metadata for the 
label \verb+title+ and the other metadata remain untouched. You can change this by using the 
\verb+update+ option, and you can also remove any metadata (even empty one) using the \verb+strip+ option.

See the documentation on \verb+map_metadata+ for more details.

A more complex example is the \verb+rewrite_metadata+ operator, which is implemented using \verb+map_metadata+ as follows:

\begin{verbatim}
# Rewrite metadata on the fly using a list of (target,rule).
# @category Source / Track Processing
# @param l  List of (target,value) rewriting rules
# @param ~insert_missing \
#           Treat track beginnings without metadata \
#           as having empty ones.
def rewrite_metadata(l,~insert_missing=true,s)
  def map(m)
    def apply(x)
      label = fst(x)
      meta = snd(x)
      if list.mem_assoc(label,l) then
        pattern = l[label]
        (label,pattern % m)
      else
        (label,meta)
      end
    end
    m = list.map(apply,m)
    def add(m,x)
      label = fst(x)
      pattern = snd(x)
      # If m does not have (label,_), then it was
      # not processed previously, we have to
      # add it now..
      if not list.mem_assoc(label,m) then
        list.append(m,[(label,pattern % m)])
      else
        m
      end
    end
    list.fold(add,m,l)
  end
  map_metadata(map,insert_missing=insert_missing,s)
end
\end{verbatim}
\subsection{Insert\_medatata}
This operator is used for inserting metadata using a server command. If you have an \verb+insert_metadata+ node named \verb+ID+ in your configuration, you can connect to the server (either telnet or socket) and execute commands like: 

\begin{verbatim}
ID.insert key1="val1",key2="val2",...
\end{verbatim}


\section{Smart crossfade}
\subsection{Basic operator}
Liquidsoap includes an advanced crossfading operator. Using it, you can code which transition you want for your songs, according to the average volume level (in dB) computed on the end of the ending track and the beginning of the new one.

The low level operator is \verb+smart_cross+. With it, you can register a function that returns the transition you like. The arguments passed to this function are:

\begin{itemize}
\item volume level for previous track
\item volume level for next track
\item metadata chunk for previous track
\item metadata chunk for next track
\item source corresponding to previous track
\item source corresponding to next track

\end{itemize}
You can find its documentation in the \href{reference.html}{language reference}.

\subsection{Example}
Liquidsoap also includes a ready-to-use operator defined using
\verb+smart_cross+, it is called \verb+smart_crossfade+ and is defined in the
pervasive helper script \verb+utils.liq+. Its code is:

\begin{verbatim}
# Crossfade between tracks, 
# taking the respective volume levels 
# into account in the choice of the 
# transition.
# @category Source / Track Processing
# @param ~start_next   Crossing duration, if any.
# @param ~fade_in      Fade-in duration, if any.
# @param ~fade_out     Fade-out duration, if any.
# @param ~width        Width of the volume analysis window.
# @param ~conservative Always prepare for
#                      a premature end-of-track.
# @param s             The input source.
def smart_crossfade (~start_next=5.,~fade_in=3.,
                     ~fade_out=3., ~width=2.,
		     ~conservative=false,s)
  high   = -20.
  medium = -32.
  margin = 4.
  fade.out = fade.out(type="sin",duration=fade_out)
  fade.in  = fade.in(type="sin",duration=fade_in)
  add = fun (a,b) -> add(normalize=false,[b,a])
  log = log(label="smart_crossfade")

  def transition(a,b,ma,mb,sa,sb)

    list.iter(fun(x)-> 
       log(level=4,"Before: #{x}"),ma)
    list.iter(fun(x)-> 
       log(level=4,"After : #{x}"),mb)

    if
      # If A and B and not too loud and close, 
      # fully cross-fade them.
      a <= medium and 
      b <= medium and 
      abs(a - b) <= margin
    then
      log("Transition: crossed, fade-in, fade-out.")
      add(fade.out(sa),fade.in(sb))

    elsif
      # If B is significantly louder than A, 
      # only fade-out A.
      # We don't want to fade almost silent things, 
      # ask for >medium.
      b >= a + margin and a >= medium and b <= high
    then
      log("Transition: crossed, fade-out.")
      add(fade.out(sa),sb)

    elsif
      # Do not fade if it's already very low.
      b >= a + margin and a <= medium and b <= high
    then
      log("Transition: crossed, no fade-out.")
      add(sa,sb)

    elsif
      # Opposite as the previous one.
      a >= b + margin and b >= medium and a <= high
    then
      log("Transition: crossed, fade-in.")
      add(sa,fade.in(sb))

    # What to do with a loud end and 
    # a quiet beginning ?
    # A good idea is to use a jingle to separate 
    # the two tracks, but that's another story.

    else
      # Otherwise, A and B are just too loud 
      # to overlap nicely, or the difference 
      # between them is too large and 
      # overlapping would completely mask one 
      # of them.
      log("No transition: just sequencing.")
      sequence([sa, sb])
    end
  end

  smart_cross(width=width, duration=start_next, 
              conservative=conservative,
              transition,s)
end
\end{verbatim}
You can use it directly in your script, or use this code to define yours!





\section{Getting some help}
Liquidsoap is a self-documented application, which means that it can provide
help about several of its aspects.  You will learn here how to get help by
yourself, by asking liquidsoap. If you do not succeed in asking the tool, you
can of course get help from humans, preferably on the mailing list
\verb+savonet-users@lists.sf.net+.

\subsection{Scripting API}
When scripting in liquidsoap, one uses functions that are either \emph{builtin}
(\emph{e.g.} \verb+fallback+ or \verb+output.icecast.vorbis+) or defined in the
\href{script_loading.html}{script library} (\emph{e.g} \verb+out+).  All these
functions come with a documentation, that you can access by executing
\verb+liquidsoap -h FUNCTION+ on the command-line. For example:

\begin{verbatim}
$ liquidsoap -h sine
*** One entry in scripting values:
Generate a sine wave.
Category: Source / Input
Type: (?id:string, ?duration:float, ?float)->source
Parameters:
* id :: string (default "")
    Force the value of the source ID.
* duration :: float (default 0.)
* (unlabeled) :: float (default 440.)
    Frequency of the sine.
\end{verbatim}
Of course if you do not know what function you need, you'd better go through the
\href{reference.html}{API reference}.

\subsection{Server commands}
The server (\cf the \href{server.html}{server} tutorial) offers some help
about its commands.  Once connected to it (either via a TCP or UNIX socket) the
\verb+help+ command will give you a list of available commands together with a
short usage line.  You can then get more detailed information about a specific
command by typing \verb+help COMMAND+:

\begin{verbatim}
$ telnet localhost 1234
Trying 127.0.0.1...
Connected to localhost.localdomain.
Escape character is '^]'.
help
Available commands:
[...]
| queue.ignore <rid>
| queue.push <uri>
| queue.queue
[...]
Type "help <command>" for more information.
END
help queue.push

Help for command queue.push.

Usage: queue.push <uri>
  Push a new request in the queue.
END
\end{verbatim}

\subsection{Settings}
Liquidsoap scripts contain expression like \verb+set("log.stdout",true)+.  These
are \emph{settings}, global variables affecting the behaviour of the
application.  Here, the first parameter identifies a setting its path, and the
second one specifies its new value.

You can have a list of available settings, with their documentation, by running
\verb+liquidsoap --conf-descr+.  If you are interested in a particular settings
section, for example server-related stuff, use
\verb+liquidsoap --conf-descr-key server+.

The output of these commands is a valid liquidsoap script, which you can edit to
set the values that you want, and load it
(\href{script_loading.html}{implicitly} or not) before you other scripts.

You can browse online the \href{settings.html}{list of available settings}.

\subsection{All plugins}
Several aspects of liquidsoap work with a notion of plugin: builtin scripting
functions, audio decoders for files and streams, metadata decoders, protocols,
etc. The list of plugins can be used to check that your build of liquidsoap has
such or such feature, or simply to browse available functions -- actually, the
\href{reference.html}{reference} is built from that output.

You can get the pretty hairy list of all available plugins from the command
\verb+liquidsoap --list-plugins+, or \verb+liquidsoap --list-plugins-xml+ for a
more parsable XML output.

\subsection{Other help resources}
TODO: the website, the mailing-lists, etc.
